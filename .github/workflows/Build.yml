name: Build

on: workflow_dispatch

jobs:
  build:
    runs-on: windows-latest
    environment: webview_build
    env:
      API_URL: ${{ secrets.API_URL }}
      API_WS_URL: ${{ secrets.API_WS_URL }}
      LOCAL_API_URL: ${{ vars.LOCAL_API_URL }}
      LOCAL_API_SECRET_KEY: ${{ secrets.LOCAL_API_SECRET_KEY }}
      API_SECRET_KEY: ${{ secrets.LOCAL_API_SECRET_KEY }}

    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Update submodules
        run: |
          git submodule update --recursive --remote

      - name: Build webview ui
        run: |
          cd T3000Webview
          npm install
          npm run build

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: i686-pc-windows-msvc

      - name: Build webview api
        run: |
          cd T3000Webview/api
          cargo build --target=i686-pc-windows-msvc --release

      - name: Get T3000 version number
        id: version
        run: |
          $version = Get-Date -Format “yyyyMMdd”
          Write-Output version=$version >> $Env:GITHUB_OUTPUT

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Build Solution
        run: |
          msbuild "T3000 - VS2019.sln" /p:Platform=x86 /p:Configuration=Release /p:ProjectVersion=${{ steps.version.outputs.version }}

      - name: Sign all executables and DLLs with SignPath
        shell: pwsh
        run: |
          # Find all .exe and .dll files in the release output
          $filesToSign = Get-ChildItem -Path "T3000 Output\release\" -Include *.exe,*.dll -Recurse -File

          foreach ($file in $filesToSign) {
            Write-Host "Signing: $($file.FullName)"

            # Submit to SignPath
            try {
              $response = Invoke-RestMethod `
                -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests" `
                -Method POST `
                -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" } `
                -Form @{
                  "Artifact" = $file
                  "ProjectSlug" = "${{ secrets.SIGNPATH_PROJECT_SLUG }}"
                  "SigningPolicySlug" = "${{ secrets.SIGNPATH_SIGNING_POLICY_SLUG }}"
                }

              $signingRequestId = $response.SigningRequestId
              Write-Host "Signing request ID: $signingRequestId"
            } catch {
              Write-Error "Failed to submit signing request for $($file.Name): $_"
              Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 10)"
              exit 1
            }

            # Wait for signing to complete (max 10 minutes)
            $maxWaitSeconds = 600
            $elapsedSeconds = 0
            do {
              Start-Sleep -Seconds 10
              $elapsedSeconds += 10
              try {
                $status = Invoke-RestMethod `
                  -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests/$signingRequestId" `
                  -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" }
                Write-Host "Status: $($status.Status) (elapsed: $elapsedSeconds seconds)"

                # Check if there are error details
                if ($status.ErrorMessage) {
                  Write-Host "Error message from SignPath: $($status.ErrorMessage)"
                }
              } catch {
                Write-Error "Failed to check signing status for $($file.Name): $_"
                exit 1
              }

              if ($elapsedSeconds -ge $maxWaitSeconds) {
                Write-Error "Timeout waiting for signing to complete for $($file.Name)"
                exit 1
              }
            } while ($status.Status -eq "Processing" -or $status.Status -eq "Submitted" -or $status.Status -eq "InProgress")

            if ($status.Status -eq "Completed") {
              # Download signed file
              try {
                Invoke-RestMethod `
                  -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests/$signingRequestId/SignedArtifact" `
                  -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" } `
                  -OutFile $file.FullName
                Write-Host "Successfully signed: $($file.Name)"
              } catch {
                Write-Error "Failed to download signed artifact for $($file.Name): $_"
                exit 1
              }
            } else {
              Write-Error "Signing failed for $($file.Name) with status: $($status.Status)"
              if ($status.ErrorMessage) {
                Write-Error "Error details: $($status.ErrorMessage)"
              }
              if ($status) {
                Write-Error "Full status object: $($status | ConvertTo-Json -Depth 10)"
              }
              exit 1
            }
          }

      - name: Clean & Orgenize Files
        continue-on-error: true
        run: |
          del "T3000 Output\release\*.pdb"
          del "T3000 Output\release\*.lib"
          del "T3000 Output\release\*.exp"
          del "T3000 Output\release\*.ilk"
          del "T3000 Output\release\ReadSinglePropDescr.xml"
          del "T3000 Output\release\BacnetExplore.exe.config"
          xcopy "T3000Webview\dist\spa\" "T3000 Output\release\ResourceFile\webview\www\" /E /H /C /I /y
          xcopy "T3000Webview\api\target\i686-pc-windows-msvc\release\t3_webview_api.dll" "T3000 Output\release\" /Y
          xcopy "T3000Webview\api\target\i686-pc-windows-msvc\release\t3_webview_api.dll.lib" "T3000 Output\release\" /Y

      - name: Verify all files are signed before MSI build
        shell: pwsh
        run: |
          Write-Host "Verifying all EXE and DLL files are properly signed..."
          
          $filesToCheck = Get-ChildItem -Path "T3000 Output\release\" -Include *.exe,*.dll -Recurse -File
          $unsignedFiles = @()
          $signedCount = 0
          
          foreach ($file in $filesToCheck) {
            $sig = Get-AuthenticodeSignature $file.FullName
            
            if ($sig.Status -eq 'Valid') {
              $signedCount++
              Write-Host "✓ Signed: $($file.Name) - Signer: $($sig.SignerCertificate.Subject)"
            } else {
              $unsignedFiles += $file.Name
              Write-Host "✗ NOT SIGNED: $($file.Name) - Status: $($sig.Status)"
            }
          }
          
          Write-Host ""
          Write-Host "===== SIGNATURE VERIFICATION SUMMARY ====="
          Write-Host "Total files checked: $($filesToCheck.Count)"
          Write-Host "Signed files: $signedCount"
          Write-Host "Unsigned files: $($unsignedFiles.Count)"
          Write-Host "=========================================="
          
          if ($unsignedFiles.Count -gt 0) {
            Write-Error "Found $($unsignedFiles.Count) unsigned files:"
            $unsignedFiles | ForEach-Object { Write-Error "  - $_" }
            Write-Error "All files must be signed before building MSI installer"
            exit 1
          }
          
          Write-Host "✓ All EXE/DLL files are properly signed and ready for MSI packaging"

      - name: Set the installer version ( doesn't accept big numbers so we add a point )
        id: iversion
        run: |
          $iversion = '${{ steps.version.outputs.version }}'
          $iversion = $iversion.Insert(4,'.')
          Write-Output iversion=$iversion >> $Env:GITHUB_OUTPUT

      - name: Build the installer
        uses: caphyon/advinst-github-action@main
        with:
          advinst-version: "21.4"
          advinst-enable-automation: "true"
          aip-path: ${{ github.workspace }}\T3000.aip
          aip-build-name: DefaultBuild
          aip-package-name: T3000-setup.msi
          aip-output-dir: ${{ github.workspace }}\setup
          aip-commands: |
            AddFolder "APPDIR" ".\T3000 Output\release" -install_in_parent_folder
            AddFolder "APPDIR" ".\T3000InstallShield\PH_Application"
            AddFolder "APPDIR" ".\T3000InstallShield\Psychrometry"
            SetProductCode -langid 1033
            SetVersion ${{ steps.iversion.outputs.iversion }}

      - name: Sign the MSI installer with SignPath
        shell: pwsh
        run: |
          $file = Get-Item "setup/T3000-setup.msi"
          Write-Host "Signing: $($file.FullName)"

          # Submit to SignPath
          try {
            $response = Invoke-RestMethod `
              -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests" `
              -Method POST `
              -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" } `
              -Form @{
                "Artifact" = $file
                "ProjectSlug" = "${{ secrets.SIGNPATH_PROJECT_SLUG }}"
                "SigningPolicySlug" = "${{ secrets.SIGNPATH_SIGNING_POLICY_SLUG }}"
              }

            $signingRequestId = $response.SigningRequestId
            Write-Host "Signing request ID: $signingRequestId"
          } catch {
            Write-Error "Failed to submit signing request: $_"
            Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 10)"
            exit 1
          }

          # Wait for signing to complete (max 10 minutes)
          $maxWaitSeconds = 600
          $elapsedSeconds = 0
          do {
            Start-Sleep -Seconds 10
            $elapsedSeconds += 10
            try {
              $status = Invoke-RestMethod `
                -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests/$signingRequestId" `
                -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" }
              
              Write-Host "Status: $($status.Status) (elapsed: $elapsedSeconds seconds)"
              Write-Host "DEBUG - Full SignPath Response:"
              Write-Host ($status | ConvertTo-Json -Depth 10)
              
              # Check if there are error details during polling
              if ($status.ErrorMessage) {
                Write-Host "Error message from SignPath: $($status.ErrorMessage)"
              }
              if ($status.ErrorDetails) {
                Write-Host "Error details from SignPath: $($status.ErrorDetails)"
              }
            } catch {
              Write-Error "Failed to check signing status: $_"
              Write-Error "Exception details: $($_.Exception.Message)"
              exit 1
            }

            if ($elapsedSeconds -ge $maxWaitSeconds) {
              Write-Error "Timeout waiting for MSI signing to complete"
              exit 1
            }
          } while ($status.Status -eq "Processing" -or $status.Status -eq "Submitted" -or $status.Status -eq "InProgress")

          if ($status.Status -eq "Completed") {
            # Download signed file
            try {
              Invoke-RestMethod `
                -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests/$signingRequestId/SignedArtifact" `
                -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" } `
                -OutFile "setup/T3000-setup.msi"
              Write-Host "Successfully signed MSI installer"
            } catch {
              Write-Error "Failed to download signed artifact: $_"
              Write-Error "Exception: $($_.Exception.Message)"
              exit 1
            }
          } else {
            Write-Error "MSI Signing FAILED!"
            Write-Error "Final Status: $($status.Status)"
            Write-Host "====== COMPLETE STATUS OBJECT ======"
            Write-Host ($status | ConvertTo-Json -Depth 10)
            Write-Host "=====================================" 
            
            # Try to extract any available error information
            $statusProps = $status.PSObject.Properties | ForEach-Object { "$($_.Name): $($_.Value)" }
            Write-Host "All status properties:"
            $statusProps | ForEach-Object { Write-Host $_ }
            
            exit 1
          }

      - name: Upload the signed installer to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: T3000-setup
          path: setup/T3000-setup.msi

      - name: Prepare & zip the update files
        run: |
          Rename-Item -Path ".\T3000 Output\release\Update.exe" -NewName "UpdateEng.exe"
          Compress-Archive -Path ".\T3000 Output\release\*" -CompressionLevel Optimal -DestinationPath .\20T3000Update.zip

      - name: Upload the update files to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: 20T3000Update
          path: T3000 Output/release/*

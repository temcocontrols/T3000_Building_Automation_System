name: Build

on: workflow_dispatch

jobs:
  build:
    runs-on: windows-latest
    environment: webview_build
    env:
      API_URL: ${{ secrets.API_URL }}
      API_WS_URL: ${{ secrets.API_WS_URL }}
      LOCAL_API_URL: ${{ vars.LOCAL_API_URL }}
      LOCAL_API_SECRET_KEY: ${{ secrets.LOCAL_API_SECRET_KEY }}
      API_SECRET_KEY: ${{ secrets.LOCAL_API_SECRET_KEY }}

    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Update submodules
        run: |
          git submodule update --recursive --remote

      - name: Build webview ui
        run: |
          cd T3000Webview
          npm install
          npm run build

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: i686-pc-windows-msvc

      - name: Build webview api
        run: |
          cd T3000Webview/api
          cargo build --target=i686-pc-windows-msvc --release

      - name: Get T3000 version number
        id: version
        run: |
          $version = Get-Date -Format “yyyyMMdd”
          Write-Output version=$version >> $Env:GITHUB_OUTPUT

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Build Solution
        run: |
          msbuild "T3000 - VS2019.sln" /p:Platform=x86 /p:Configuration=Release /p:ProjectVersion=${{ steps.version.outputs.version }}

      - name: Clean & Orgenize Files
        continue-on-error: true
        run: |
          del "T3000 Output\release\*.pdb"
          del "T3000 Output\release\*.lib"
          del "T3000 Output\release\*.exp"
          del "T3000 Output\release\*.ilk"
          del "T3000 Output\release\ReadSinglePropDescr.xml"
          del "T3000 Output\release\BacnetExplore.exe.config"
          xcopy "T3000Webview\dist\spa\" "T3000 Output\release\ResourceFile\webview\www\" /E /H /C /I /y
          xcopy "T3000Webview\api\target\i686-pc-windows-msvc\release\t3_webview_api.dll" "T3000 Output\release\" /Y
          xcopy "T3000Webview\api\target\i686-pc-windows-msvc\release\t3_webview_api.dll.lib" "T3000 Output\release\" /Y

      - name: Sign all executables and DLLs with SignPath
        shell: pwsh
        run: |
          Write-Host "Preparing files for batch signing with SignPath..."

          # Define files to sign (only OUR files, exclude 3rd party libraries)
          $filesToSign = @(
            "T3000 Output\release\T3000.exe",
            "T3000 Output\release\BacnetExplore.exe",
            "T3000 Output\release\ISP.exe",
            "T3000 Output\release\ModbusPoll.exe",
            "T3000 Output\release\Update.exe",
            "T3000 Output\release\BACnet_Stack_Library.dll",
            "T3000 Output\release\FlexSlideBar.dll",
            "T3000 Output\release\ModbusDllforVc.dll",
            "T3000 Output\release\T3000Controls.dll",
            "T3000 Output\release\t3_webview_api.dll"
          )

          # Exclude 3rd party libraries that we don't own:
          # - sqlite3.dll (SQLite project)
          # - WebView2Loader.dll (Microsoft)

          # Verify all files exist before signing
          $missingFiles = @()
          foreach ($file in $filesToSign) {
            if (-not (Test-Path $file)) {
              $missingFiles += $file
            } else {
              Write-Host "  ✓ Found: $file"
            }
          }

          if ($missingFiles.Count -gt 0) {
            Write-Error "Missing files that need to be signed:"
            $missingFiles | ForEach-Object { Write-Error "  - $_" }
            exit 1
          }

          # Create temporary directory to organize files for ZIP (preserve names)
          $timestamp = Get-Date -Format "yyyyMMddHHmmss"
          $tempDir = "temp-signing-$timestamp"
          New-Item -ItemType Directory -Path $tempDir -Force | Out-Null

          # Copy files to temp directory (flattened structure)
          Write-Host "Copying files to temporary directory..."
          foreach ($file in $filesToSign) {
            $fileName = Split-Path $file -Leaf
            Copy-Item $file -Destination "$tempDir\$fileName" -Force
            Write-Host "  Copied: $fileName"
          }

          # Create ZIP artifact for batch signing
          $zipPath = "T3000-unsigned-$timestamp.zip"
          Write-Host "Creating ZIP artifact: $zipPath"

          Compress-Archive -Path "$tempDir\*" -DestinationPath $zipPath -Force

          Write-Host "Submitting ZIP artifact to SignPath for batch signing..."

          # Submit ZIP to SignPath
          try {
            $response = Invoke-RestMethod `
              -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests" `
              -Method POST `
              -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" } `
              -Form @{
                "Artifact" = Get-Item $zipPath
                "ProjectSlug" = "${{ secrets.SIGNPATH_PROJECT_SLUG }}"
                "SigningPolicySlug" = "${{ secrets.SIGNPATH_SIGNING_POLICY_SLUG }}"
              }

            $signingRequestId = $response.SigningRequestId
            Write-Host "✓ Signing request submitted successfully"
            Write-Host "  Request ID: $signingRequestId"
          } catch {
            Write-Error "Failed to submit signing request: $_"
            Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 10)"
            exit 1
          }

          # Wait for signing to complete (max 15 minutes for batch)
          $maxWaitSeconds = 900
          $elapsedSeconds = 0
          Write-Host "Waiting for SignPath to process batch signing..."

          do {
            Start-Sleep -Seconds 15
            $elapsedSeconds += 15
            try {
              $status = Invoke-RestMethod `
                -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests/$signingRequestId" `
                -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" }

              Write-Host "  Status: $($status.Status) (elapsed: $($elapsedSeconds)s / $($maxWaitSeconds)s)"

              if ($status.ErrorMessage) {
                Write-Host "  ⚠ Error message: $($status.ErrorMessage)"
              }
            } catch {
              Write-Error "Failed to check signing status: $_"
              exit 1
            }

            if ($elapsedSeconds -ge $maxWaitSeconds) {
              Write-Error "Timeout waiting for batch signing to complete (15 minutes)"
              exit 1
            }
          } while ($status.Status -eq "Processing" -or $status.Status -eq "Submitted" -or $status.Status -eq "InProgress")

          if ($status.Status -eq "Completed") {
            Write-Host "✓ Batch signing completed successfully"

            # Download signed ZIP
            $signedZipPath = "T3000-signed-$timestamp.zip"
            try {
              Invoke-RestMethod `
                -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests/$signingRequestId/SignedArtifact" `
                -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" } `
                -OutFile $signedZipPath

              Write-Host "✓ Downloaded signed artifact: $signedZipPath"

              # Extract signed files to temporary directory
              $signedTempDir = "temp-signed-$timestamp"
              Write-Host "Extracting signed files..."
              Expand-Archive -Path $signedZipPath -DestinationPath $signedTempDir -Force

              # Copy signed files back to original locations
              Write-Host "Copying signed files back to release directory..."
              foreach ($originalPath in $filesToSign) {
                $fileName = Split-Path $originalPath -Leaf
                $signedFile = "$signedTempDir\$fileName"

                if (Test-Path $signedFile) {
                  Copy-Item $signedFile -Destination $originalPath -Force
                  Write-Host "  ✓ Replaced: $fileName"
                } else {
                  Write-Error "  ✗ Missing from signed ZIP: $fileName"
                  exit 1
                }
              }

              # Cleanup temporary directories
              Remove-Item $tempDir -Recurse -Force -ErrorAction SilentlyContinue
              Remove-Item $signedTempDir -Recurse -Force -ErrorAction SilentlyContinue

              Write-Host "✓ Successfully replaced all files with signed versions"

            } catch {
              Write-Error "Failed to download signed artifact: $_"
              exit 1
            }
          } else {
            Write-Error "Batch signing FAILED with status: $($status.Status)"
            if ($status.ErrorMessage) {
              Write-Error "Error details: $($status.ErrorMessage)"
            }
            Write-Host "Full status object:"
            Write-Host ($status | ConvertTo-Json -Depth 10)
            exit 1
          }

      - name: Verify all files are signed before MSI build
        shell: pwsh
        run: |
          Write-Host "Verifying signed EXE and DLL files..."
          Write-Host ""

          # Only verify OUR files (exclude 3rd party libraries we don't sign)
          $filesToVerify = @(
            "T3000 Output\release\T3000.exe",
            "T3000 Output\release\BacnetExplore.exe",
            "T3000 Output\release\ISP.exe",
            "T3000 Output\release\ModbusPoll.exe",
            "T3000 Output\release\Update.exe",
            "T3000 Output\release\BACnet_Stack_Library.dll",
            "T3000 Output\release\FlexSlideBar.dll",
            "T3000 Output\release\ModbusDllforVc.dll",
            "T3000 Output\release\T3000Controls.dll",
            "T3000 Output\release\t3_webview_api.dll"
          )

          $unsignedFiles = @()
          $signedCount = 0
          $thirdPartyFiles = @("sqlite3.dll", "WebView2Loader.dll")

          foreach ($filePath in $filesToVerify) {
            if (-not (Test-Path $filePath)) {
              Write-Host "✗ MISSING: $filePath"
              $unsignedFiles += $filePath
              continue
            }

            $sig = Get-AuthenticodeSignature $filePath

            if ($sig.Status -eq 'Valid') {
              $signedCount++
              $fileName = Split-Path $filePath -Leaf
              Write-Host "✓ Signed: $fileName"
              Write-Host "  Signer: $($sig.SignerCertificate.Subject)"
            } else {
              $unsignedFiles += $filePath
              $fileName = Split-Path $filePath -Leaf
              Write-Host "✗ NOT SIGNED: $fileName - Status: $($sig.Status)"
            }
          }

          Write-Host ""
          Write-Host "===== SIGNATURE VERIFICATION SUMMARY ====="
          Write-Host "Our files checked: $($filesToVerify.Count)"
          Write-Host "Successfully signed: $signedCount"
          Write-Host "Failed/Unsigned: $($unsignedFiles.Count)"
          Write-Host ""
          Write-Host "Third-party files (not signed by us):"
          foreach ($file in $thirdPartyFiles) {
            Write-Host "  ℹ $file (Microsoft/Open Source)"
          }
          Write-Host "=========================================="

          if ($unsignedFiles.Count -gt 0) {
            Write-Error ""
            Write-Error "Found $($unsignedFiles.Count) unsigned files:"
            $unsignedFiles | ForEach-Object {
              $fileName = Split-Path $_ -Leaf
              Write-Error "  - $fileName"
            }
            Write-Error ""
            Write-Error "All Temco files must be signed before building MSI installer"
            exit 1
          }

          Write-Host ""
          Write-Host "✓ All Temco executables and DLLs are properly signed"
          Write-Host "✓ Ready for MSI packaging"

      - name: Set the installer version ( doesn't accept big numbers so we add a point )
        id: iversion
        run: |
          $iversion = '${{ steps.version.outputs.version }}'
          $iversion = $iversion.Insert(4,'.')
          Write-Output iversion=$iversion >> $Env:GITHUB_OUTPUT

      - name: Build the installer
        uses: caphyon/advinst-github-action@main
        with:
          advinst-version: "21.4"
          advinst-enable-automation: "true"
          aip-path: ${{ github.workspace }}\T3000.aip
          aip-build-name: DefaultBuild
          aip-package-name: T3000-setup.msi
          aip-output-dir: ${{ github.workspace }}\setup
          aip-commands: |
            AddFolder "APPDIR" ".\T3000 Output\release" -install_in_parent_folder
            AddFolder "APPDIR" ".\T3000InstallShield\PH_Application"
            AddFolder "APPDIR" ".\T3000InstallShield\Psychrometry"
            SetProductCode -langid 1033
            SetVersion ${{ steps.iversion.outputs.iversion }}

      - name: Sign the MSI installer with SignPath
        shell: pwsh
        run: |
          $file = Get-Item "setup/T3000-setup.msi"
          Write-Host "Signing: $($file.FullName)"

          # Submit to SignPath
          try {
            $response = Invoke-RestMethod `
              -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests" `
              -Method POST `
              -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" } `
              -Form @{
                "Artifact" = $file
                "ProjectSlug" = "${{ secrets.SIGNPATH_PROJECT_SLUG }}"
                "SigningPolicySlug" = "${{ secrets.SIGNPATH_SIGNING_POLICY_SLUG }}"
              }

            $signingRequestId = $response.SigningRequestId
            Write-Host "Signing request ID: $signingRequestId"
          } catch {
            Write-Error "Failed to submit signing request: $_"
            Write-Error "Response: $($_.Exception.Response | ConvertTo-Json -Depth 10)"
            exit 1
          }

          # Wait for signing to complete (max 10 minutes)
          $maxWaitSeconds = 600
          $elapsedSeconds = 0
          do {
            Start-Sleep -Seconds 10
            $elapsedSeconds += 10
            try {
              $status = Invoke-RestMethod `
                -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests/$signingRequestId" `
                -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" }

              Write-Host "Status: $($status.Status) (elapsed: $elapsedSeconds seconds)"
              Write-Host "DEBUG - Full SignPath Response:"
              Write-Host ($status | ConvertTo-Json -Depth 10)

              # Check if there are error details during polling
              if ($status.ErrorMessage) {
                Write-Host "Error message from SignPath: $($status.ErrorMessage)"
              }
              if ($status.ErrorDetails) {
                Write-Host "Error details from SignPath: $($status.ErrorDetails)"
              }
            } catch {
              Write-Error "Failed to check signing status: $_"
              Write-Error "Exception details: $($_.Exception.Message)"
              exit 1
            }

            if ($elapsedSeconds -ge $maxWaitSeconds) {
              Write-Error "Timeout waiting for MSI signing to complete"
              exit 1
            }
          } while ($status.Status -eq "Processing" -or $status.Status -eq "Submitted" -or $status.Status -eq "InProgress")

          if ($status.Status -eq "Completed") {
            # Download signed file
            try {
              Invoke-RestMethod `
                -Uri "https://app.signpath.io/API/v1/${{ secrets.SIGNPATH_ORGANIZATION_ID }}/SigningRequests/$signingRequestId/SignedArtifact" `
                -Headers @{ "Authorization" = "Bearer ${{ secrets.SIGNPATH_API_TOKEN }}" } `
                -OutFile "setup/T3000-setup.msi"
              Write-Host "Successfully signed MSI installer"
            } catch {
              Write-Error "Failed to download signed artifact: $_"
              Write-Error "Exception: $($_.Exception.Message)"
              exit 1
            }
          } else {
            Write-Error "MSI Signing FAILED!"
            Write-Error "Final Status: $($status.Status)"
            Write-Host "====== COMPLETE STATUS OBJECT ======"
            Write-Host ($status | ConvertTo-Json -Depth 10)
            Write-Host "====================================="

            # Try to extract any available error information
            $statusProps = $status.PSObject.Properties | ForEach-Object { "$($_.Name): $($_.Value)" }
            Write-Host "All status properties:"
            $statusProps | ForEach-Object { Write-Host $_ }

            exit 1
          }

      - name: Upload the signed installer to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: T3000-setup
          path: setup/T3000-setup.msi

      - name: Prepare & zip the update files
        run: |
          Rename-Item -Path ".\T3000 Output\release\Update.exe" -NewName "UpdateEng.exe"
          Compress-Archive -Path ".\T3000 Output\release\*" -CompressionLevel Optimal -DestinationPath .\20T3000Update.zip

      - name: Upload the update files to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: 20T3000Update
          path: T3000 Output/release/*
